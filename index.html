<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Three.js – 垂直リング＋水平地平線＋マウスカメラ</title>
  <style>
    body { margin:0; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // シーン＆レンダラー
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // カメラ（水平を保つ lookAt）
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 30);
    camera.lookAt(0, camera.position.y, 0);

    window.addEventListener('resize', ()=> {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // 地平線ライン
    const horizonGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-1000,0,0), new THREE.Vector3(1000,0,0)
    ]);
    scene.add(new THREE.Line(horizonGeo, new THREE.LineBasicMaterial({color:0x000000})));

    // リング群
    const ringCount = 10, spacing = 25, farZ = -spacing*ringCount, outerR = 5, rings=[];
    const geo = new THREE.RingGeometry(outerR-0.5, outerR, 64);
    const mat = new THREE.MeshBasicMaterial({ color:0x000000, side:THREE.DoubleSide });

    for(let i=0;i<ringCount;i++){
      const m = new THREE.Mesh(geo, mat);
      m.rotation.x = Math.PI/2;               // ← この１行を入れて「縦に立てる」
      m.position.y = outerR;                  // 底が y=0 に接着
      m.position.z = -spacing*(i+1);
      m.position.x = Math.random()*20-10;
      scene.add(m);
      rings.push(m);
    }

    // マウスでカメラパン＆チルト（ピッチは常に0）
    const maxX=20, maxY=5;
    function onMove(e){
      const x = (e.clientX||e.touches[0].clientX)/innerWidth*2-1;
      const y = (e.clientY||e.touches[0].clientY)/innerHeight*2-1;
      camera.position.x = x*maxX;
      camera.position.y = outerR + y*maxY;
      camera.lookAt(0, camera.position.y, 0);
    }
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove);

    // アニメーション
    const speed = 0.5;
    (function loop(){
      requestAnimationFrame(loop);
      rings.forEach(r=>{
        r.position.z += speed;
        if(r.position.z > camera.position.z-1){
          r.position.z = farZ;
          r.position.x = Math.random()*20-10;
        }
      });
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
